<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trust Anchor - Complete Demo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        .demo-section {
            margin: 30px 0;
            padding: 25px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            background: #f7fafc;
        }
        .demo-section h2 {
            color: #2d3748;
            border-bottom: 2px solid #4299e1;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .step {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border-left: 4px solid #4299e1;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .step h3 {
            color: #2b6cb0;
            margin-top: 0;
        }
        button {
            background: #4299e1;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: background 0.3s;
        }
        button:hover {
            background: #3182ce;
        }
        button:disabled {
            background: #a0aec0;
            cursor: not-allowed;
        }
        .success {
            background: #c6f6d5;
            border-left-color: #38a169;
            color: #22543d;
        }
        .error {
            background: #fed7d7;
            border-left-color: #e53e3e;
            color: #742a2a;
        }
        .info {
            background: #bee3f8;
            border-left-color: #3182ce;
            color: #2a4365;
        }
        .code {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            overflow-x: auto;
            margin: 10px 0;
        }
        .result {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            white-space: pre-wrap;
        }
        .status {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .status.verified {
            background: #c6f6d5;
            color: #22543d;
        }
        .status.unverified {
            background: #fed7d7;
            color: #742a2a;
        }
        .status.pending {
            background: #fef5e7;
            color: #744210;
        }
        .meta-tag {
            background: #f0fff4;
            border: 1px solid #9ae6b4;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            word-break: break-all;
        }
        .demo-content {
            background: #f7fafc;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid #e2e8f0;
        }
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .feature-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .feature-card h4 {
            color: #2b6cb0;
            margin-top: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê Trust Anchor - Complete Feature Demo</h1>
        
        <div class="demo-section">
            <h2>üéØ Demo Overview</h2>
            <p>This demo showcases the complete Trust Anchor verification cycle:</p>
            <div class="feature-grid">
                <div class="feature-card">
                    <h4>üîë Key Generation</h4>
                    <p>Generate cryptographic key pairs for content signing</p>
                </div>
                <div class="feature-card">
                    <h4>‚úçÔ∏è Content Signing</h4>
                    <p>Sign content with private keys to create digital signatures</p>
                </div>
                <div class="feature-card">
                    <h4>üè∑Ô∏è Meta Tag Integration</h4>
                    <p>Embed verification data in HTML meta tags</p>
                </div>
                <div class="feature-card">
                    <h4>‚úÖ Content Verification</h4>
                    <p>Verify content authenticity using public keys</p>
                </div>
                <div class="feature-card">
                    <h4>üåê API Integration</h4>
                    <p>Programmatic verification via REST API</p>
                </div>
                <div class="feature-card">
                    <h4>üîç Chrome Extension</h4>
                    <p>Automatic verification in the browser</p>
                </div>
            </div>
        </div>

        <div class="demo-section">
            <h2>üîë Step 1: Key Generation</h2>
            <div class="step">
                <h3>Generate Cryptographic Key Pair</h3>
                <p>First, we need to generate a cryptographic key pair for signing content.</p>
                <button onclick="generateKeys()">Generate New Keys</button>
                <div id="keyResult" class="result" style="display: none;"></div>
            </div>
        </div>

        <div class="demo-section">
            <h2>‚úçÔ∏è Step 2: Content Signing</h2>
            <div class="step">
                <h3>Sign Demo Content</h3>
                <p>Sign the demo content with your private key to create a digital signature.</p>
                <div class="demo-content">
                    <strong>Content to Sign:</strong><br>
                    <em>"This is a demo of Trust Anchor content verification. This content will be cryptographically signed to ensure its authenticity and prevent tampering."</em>
                </div>
                <button onclick="signContent()" id="signBtn" disabled>Sign Content</button>
                <div id="signResult" class="result" style="display: none;"></div>
            </div>
        </div>

        <div class="demo-section">
            <h2>üè∑Ô∏è Step 3: Meta Tag Integration</h2>
            <div class="step">
                <h3>Add Verification Meta Tag</h3>
                <p>Add the verification data to this page's HTML meta tags.</p>
                <button onclick="addMetaTag()" id="metaBtn" disabled>Add Meta Tag</button>
                <div id="metaResult" class="result" style="display: none;"></div>
            </div>
        </div>

        <div class="demo-section">
            <h2>‚úÖ Step 4: Content Verification</h2>
            <div class="step">
                <h3>Verify Content Authenticity</h3>
                <p>Verify that the content hasn't been tampered with using the public key.</p>
                <button onclick="verifyContent()" id="verifyBtn" disabled>Verify Content</button>
                <div id="verifyResult" class="result" style="display: none;"></div>
            </div>
        </div>

        <div class="demo-section">
            <h2>üåê Step 5: API Verification</h2>
            <div class="step">
                <h3>Verify via REST API</h3>
                <p>Use the Trust Anchor API to verify this page's content.</p>
                <button onclick="verifyViaAPI()" id="apiBtn" disabled>Verify via API</button>
                <div id="apiResult" class="result" style="display: none;"></div>
            </div>
        </div>

        <div class="demo-section">
            <h2>üîç Step 6: Chrome Extension Demo</h2>
            <div class="step">
                <h3>Browser Extension Verification</h3>
                <p>If you have the Trust Anchor Chrome extension installed, it should automatically detect and verify this page.</p>
                <div class="info">
                    <strong>Extension Status:</strong> 
                    <span id="extensionStatus" class="status pending">Checking...</span>
                </div>
                <div id="extensionResult" class="result" style="display: none;"></div>
            </div>
        </div>

        <div class="demo-section">
            <h2>üé≠ Step 7: Tampering Demo</h2>
            <div class="step">
                <h3>Demonstrate Tamper Detection</h3>
                <p>Modify the content and see how Trust Anchor detects tampering.</p>
                <button onclick="simulateTampering()" id="tamperBtn" disabled>Simulate Tampering</button>
                <div id="tamperResult" class="result" style="display: none;"></div>
            </div>
        </div>

        <div class="demo-section">
            <h2>üìä Demo Summary</h2>
            <div class="step">
                <h3>Complete Verification Cycle</h3>
                <div id="summaryResult" class="result">
                    Demo not yet completed. Follow the steps above to see the full Trust Anchor verification cycle.
                </div>
            </div>
        </div>
    </div>

    <script>
        let generatedKeys = null;
        let signedContent = null;
        let metaTagAdded = false;
        let verificationResults = [];

        // Step 1: Key Generation
        async function generateKeys() {
            const resultDiv = document.getElementById('keyResult');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result info';
            resultDiv.textContent = 'Generating cryptographic key pair...';

            try {
                // Generate key pair using Web Crypto API
                const keyPair = await window.crypto.subtle.generateKey(
                    {
                        name: "RSASSA-PKCS1-v1_5",
                        modulusLength: 2048,
                        publicExponent: new Uint8Array([1, 0, 1]),
                        hash: "SHA-256",
                    },
                    true,
                    ["sign", "verify"]
                );

                // Export public key
                const publicKeyBuffer = await window.crypto.subtle.exportKey("spki", keyPair.publicKey);
                const publicKeyBase64 = btoa(String.fromCharCode(...new Uint8Array(publicKeyBuffer)));

                // Store keys
                generatedKeys = {
                    privateKey: keyPair.privateKey,
                    publicKey: publicKeyBase64,
                    keyId: await generateKeyId(publicKeyBase64)
                };

                // Store public key in backend
                await storePublicKey(generatedKeys.publicKey, generatedKeys.keyId);

                resultDiv.className = 'result success';
                resultDiv.textContent = `‚úÖ Keys generated successfully!\n\nKey ID: ${generatedKeys.keyId}\nPublic Key: ${generatedKeys.publicKey.substring(0, 50)}...\n\nKeys stored in backend for verification.`;

                document.getElementById('signBtn').disabled = false;
                updateSummary();
            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.textContent = `‚ùå Error generating keys: ${error.message}`;
            }
        }

        // Generate key ID from public key
        async function generateKeyId(publicKey) {
            const encoder = new TextEncoder();
            const data = encoder.encode(publicKey);
            const hashBuffer = await window.crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Store public key in backend
        async function storePublicKey(publicKey, keyId) {
            try {
                const response = await fetch('http://localhost:3000/api/keys', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ publicKey })
                });
                const result = await response.json();
                if (!result.success) {
                    throw new Error(result.error || 'Failed to store key');
                }
            } catch (error) {
                console.error('Error storing public key:', error);
                throw error;
            }
        }

        // Step 2: Content Signing
        async function signContent() {
            if (!generatedKeys) {
                alert('Please generate keys first!');
                return;
            }

            const resultDiv = document.getElementById('signResult');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result info';
            resultDiv.textContent = 'Signing content...';

            try {
                const content = "This is a demo of Trust Anchor content verification. This content will be cryptographically signed to ensure its authenticity and prevent tampering.";
                
                // Hash the content
                const encoder = new TextEncoder();
                const data = encoder.encode(content);
                const hashBuffer = await window.crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                // Sign the hash
                const signatureBuffer = await window.crypto.subtle.sign(
                    "RSASSA-PKCS1-v1_5",
                    generatedKeys.privateKey,
                    hashBuffer
                );
                const signatureArray = Array.from(new Uint8Array(signatureBuffer));
                const signature = btoa(String.fromCharCode(...signatureArray));

                signedContent = {
                    content,
                    hash,
                    signature,
                    keyId: generatedKeys.keyId
                };

                resultDiv.className = 'result success';
                resultDiv.textContent = `‚úÖ Content signed successfully!\n\nContent: "${content}"\nHash: ${hash}\nSignature: ${signature.substring(0, 50)}...\nKey ID: ${generatedKeys.keyId}`;

                document.getElementById('metaBtn').disabled = false;
                updateSummary();
            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.textContent = `‚ùå Error signing content: ${error.message}`;
            }
        }

        // Step 3: Meta Tag Integration
        function addMetaTag() {
            if (!signedContent) {
                alert('Please sign content first!');
                return;
            }

            const resultDiv = document.getElementById('metaResult');
            resultDiv.style.display = 'block';

            try {
                // Create meta tag content
                const metaContent = JSON.stringify({
                    hash: signedContent.hash,
                    signature: signedContent.signature,
                    keyId: signedContent.keyId
                });

                // Add meta tag to page
                const metaTag = document.createElement('meta');
                metaTag.name = 'ai-trust-anchor';
                metaTag.content = metaContent;
                document.head.appendChild(metaTag);

                metaTagAdded = true;

                resultDiv.className = 'result success';
                resultDiv.innerHTML = `‚úÖ Meta tag added successfully!\n\nMeta tag content:\n<div class="meta-tag">${metaContent}</div>`;

                document.getElementById('verifyBtn').disabled = false;
                document.getElementById('apiBtn').disabled = false;
                document.getElementById('tamperBtn').disabled = false;
                updateSummary();
            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.textContent = `‚ùå Error adding meta tag: ${error.message}`;
            }
        }

        // Step 4: Content Verification
        async function verifyContent() {
            if (!signedContent) {
                alert('Please sign content first!');
                return;
            }

            const resultDiv = document.getElementById('verifyResult');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result info';
            resultDiv.textContent = 'Verifying content...';

            try {
                // Re-hash the content
                const encoder = new TextEncoder();
                const data = encoder.encode(signedContent.content);
                const hashBuffer = await window.crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const actualHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                // Verify signature
                const signatureArray = Uint8Array.from(atob(signedContent.signature), c => c.charCodeAt(0));
                const isValid = await window.crypto.subtle.verify(
                    "RSASSA-PKCS1-v1_5",
                    await window.crypto.subtle.importKey(
                        "spki",
                        Uint8Array.from(atob(generatedKeys.publicKey), c => c.charCodeAt(0)),
                        { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
                        false,
                        ["verify"]
                    ),
                    signatureArray,
                    hashBuffer
                );

                const verificationResult = {
                    step: 'Content Verification',
                    hashMatch: actualHash === signedContent.hash,
                    signatureValid: isValid,
                    verified: actualHash === signedContent.hash && isValid
                };

                verificationResults.push(verificationResult);

                if (verificationResult.verified) {
                    resultDiv.className = 'result success';
                    resultDiv.textContent = `‚úÖ Content verified successfully!\n\nHash Match: ${verificationResult.hashMatch}\nSignature Valid: ${verificationResult.signatureValid}\nOverall Status: VERIFIED`;
                } else {
                    resultDiv.className = 'result error';
                    resultDiv.textContent = `‚ùå Content verification failed!\n\nHash Match: ${verificationResult.hashMatch}\nSignature Valid: ${verificationResult.signatureValid}\nOverall Status: FAILED`;
                }

                updateSummary();
            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.textContent = `‚ùå Error verifying content: ${error.message}`;
            }
        }

        // Step 5: API Verification
        async function verifyViaAPI() {
            if (!metaTagAdded) {
                alert('Please add meta tag first!');
                return;
            }

            const resultDiv = document.getElementById('apiResult');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result info';
            resultDiv.textContent = 'Verifying via API...';

            try {
                const response = await fetch('http://localhost:3000/api/verify', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: window.location.href })
                });

                const result = await response.json();
                
                const verificationResult = {
                    step: 'API Verification',
                    verified: result.verified,
                    status: result.status,
                    details: result.details
                };

                verificationResults.push(verificationResult);

                if (result.verified) {
                    resultDiv.className = 'result success';
                    resultDiv.textContent = `‚úÖ API verification successful!\n\nStatus: ${result.status}\nDetails: ${result.details}\nTimestamp: ${result.timestamp}`;
                } else {
                    resultDiv.className = 'result error';
                    resultDiv.textContent = `‚ùå API verification failed!\n\nStatus: ${result.status}\nDetails: ${result.details}\nTimestamp: ${result.timestamp}`;
                }

                updateSummary();
            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.textContent = `‚ùå Error during API verification: ${error.message}`;
            }
        }

        // Step 6: Chrome Extension Demo
        function checkExtensionStatus() {
            const statusSpan = document.getElementById('extensionStatus');
            const resultDiv = document.getElementById('extensionResult');
            
            // Check if extension is installed (this is a simplified check)
            if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.id) {
                statusSpan.textContent = 'Installed';
                statusSpan.className = 'status verified';
                resultDiv.style.display = 'block';
                resultDiv.className = 'result success';
                resultDiv.textContent = '‚úÖ Trust Anchor Chrome extension detected!\n\nThe extension should automatically verify this page and show the verification status in the browser toolbar.';
            } else {
                statusSpan.textContent = 'Not Detected';
                statusSpan.className = 'status unverified';
                resultDiv.style.display = 'block';
                resultDiv.className = 'result info';
                resultDiv.textContent = '‚ÑπÔ∏è Trust Anchor Chrome extension not detected.\n\nTo install the extension:\n1. Load the extension from the extension/ folder\n2. Enable it in Chrome\n3. Refresh this page';
            }
        }

        // Step 7: Tampering Demo
        function simulateTampering() {
            const resultDiv = document.getElementById('tamperResult');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result info';
            resultDiv.textContent = 'Simulating content tampering...';

            try {
                // Modify the content slightly
                const originalContent = signedContent.content;
                const tamperedContent = originalContent + " (TAMPERED)";
                
                // Re-hash the tampered content
                const encoder = new TextEncoder();
                const data = encoder.encode(tamperedContent);
                const hashBuffer = window.crypto.subtle.digest('SHA-256', data);
                
                hashBuffer.then(buffer => {
                    const hashArray = Array.from(new Uint8Array(buffer));
                    const tamperedHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                    
                    const verificationResult = {
                        step: 'Tamper Detection',
                        originalHash: signedContent.hash,
                        tamperedHash: tamperedHash,
                        hashMatch: false,
                        detected: true
                    };

                    verificationResults.push(verificationResult);

                    resultDiv.className = 'result error';
                    resultDiv.textContent = `‚ùå Tampering detected!\n\nOriginal Hash: ${signedContent.hash}\nTampered Hash: ${tamperedHash}\nHash Match: FALSE\n\nTrust Anchor successfully detected the content modification!`;

                    updateSummary();
                });
            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.textContent = `‚ùå Error simulating tampering: ${error.message}`;
            }
        }

        // Update demo summary
        function updateSummary() {
            const summaryDiv = document.getElementById('summaryResult');
            let summary = 'üîê Trust Anchor Demo Progress:\n\n';
            
            if (generatedKeys) {
                summary += '‚úÖ Step 1: Keys Generated\n';
            }
            if (signedContent) {
                summary += '‚úÖ Step 2: Content Signed\n';
            }
            if (metaTagAdded) {
                summary += '‚úÖ Step 3: Meta Tag Added\n';
            }
            
            if (verificationResults.length > 0) {
                summary += '\nüîç Verification Results:\n';
                verificationResults.forEach(result => {
                    const status = result.verified ? '‚úÖ' : '‚ùå';
                    summary += `${status} ${result.step}: ${result.verified ? 'PASSED' : 'FAILED'}\n`;
                });
            }
            
            if (generatedKeys && signedContent && metaTagAdded && verificationResults.length > 0) {
                summary += '\nüéâ Demo Complete!\n\nTrust Anchor successfully demonstrated:\n';
                summary += '‚Ä¢ Cryptographic key generation\n';
                summary += '‚Ä¢ Content signing and verification\n';
                summary += '‚Ä¢ Meta tag integration\n';
                summary += '‚Ä¢ API-based verification\n';
                summary += '‚Ä¢ Tamper detection\n';
            }
            
            summaryDiv.textContent = summary;
        }

        // Initialize demo
        window.addEventListener('load', function() {
            checkExtensionStatus();
            updateSummary();
        });
    </script>
</body>
</html> 